// @ts-nocheck
const mockExecPromiseFn = jest.fn();

jest.mock('node:util', () => ({
  promisify: jest.fn().mockReturnValue(mockExecPromiseFn)
}));
jest.mock('node:child_process', () => ({
  exec: jest.fn()
}));
jest.mock('../../src/TtyOutputReader.js', () => ({
  __esModule: true,
  default: {
    retrieveBuffer: jest.fn().mockResolvedValue('Mocked terminal output')
  }
}));
jest.mock('node:fs', () => ({
  openSync: jest.fn().mockReturnValue(1),
  closeSync: jest.fn(),
  existsSync: jest.fn().mockReturnValue(true)
}));

import { jest, describe, expect, test, beforeEach } from '@jest/globals';

// Use dynamic import for ESM compatibility and to ensure mocks are in place

describe('CommandExecutor', () => {
  let CommandExecutor;
  let commandExecutor;
  let TtyOutputReader;

  beforeEach(async () => {
    jest.clearAllMocks();
    // Dynamically import after mocks
    CommandExecutor = (await import('../../src/CommandExecutor.js')).default;
    TtyOutputReader = (await import('../../src/TtyOutputReader.js')).default;
    jest.spyOn(TtyOutputReader, 'retrieveBuffer').mockResolvedValue('Mocked terminal output');
    mockExecPromiseFn.mockImplementation((command) => {
      if (command.includes('get tty')) {
        return Promise.resolve({ stdout: '/dev/ttys000\n', stderr: '' });
      } else if (command.includes('get is processing')) {
        return Promise.resolve({ stdout: 'false\n', stderr: '' });
      } else {
        return Promise.resolve({ stdout: '', stderr: '' });
      }
    });
    // Inject the mockExecPromiseFn into CommandExecutor
    commandExecutor = new CommandExecutor(mockExecPromiseFn);
  });

  test('executeCommand passes the command to execPromise', async () => {
    const testCommand = 'echo "Hello World"';
    await commandExecutor.executeCommand(testCommand);
    // Find the call that contains osascript and the user's command (escaped)
    const calledWith = mockExecPromiseFn.mock.calls.find(call =>
      call[0].includes('osascript') && call[0].includes('Hello World')
    );
    expect(calledWith).toBeTruthy();
  });

  test('escapeForAppleScript handles various Unicode characters', async () => {
    const testCommand = 'echo ðŸš€ cafÃ© ä¸­æ–‡ ðŸŽ¯';
    const escapedCommand = commandExecutor.escapeForAppleScript(testCommand);

    expect(escapedCommand).toBe('echo ðŸš€ cafÃ© ä¸­æ–‡ ðŸŽ¯');
  });

  test('escapeForAppleScript still escapes control characters', async () => {
    const testCommand = 'echo\ttest\nline';  // tab and newline
    const escapedCommand = commandExecutor.escapeForAppleScript(testCommand);

    // This should use multiline handling since it contains newlines
    expect(escapedCommand).toContain('return');
    expect(escapedCommand).not.toContain('\t');
    expect(escapedCommand).not.toContain('\n');
  });

  describe('session targeting', () => {
    test('targets active session when no sessionId provided', async () => {
      const executor = new CommandExecutor(mockExecPromiseFn);
      await executor.executeCommand('test');

      const calledWith = mockExecPromiseFn.mock.calls.find(call =>
        call[0].includes('osascript') && call[0].includes('write text')
      );
      expect(calledWith[0]).toContain('current session of current window');
    });

    test('targets active session when sessionId is "active"', async () => {
      const executor = new CommandExecutor(mockExecPromiseFn, 'active');
      await executor.executeCommand('test');

      const calledWith = mockExecPromiseFn.mock.calls.find(call =>
        call[0].includes('osascript') && call[0].includes('write text')
      );
      expect(calledWith[0]).toContain('current session of current window');
    });

    test('targets specific session when sessionId is provided', async () => {
      const executor = new CommandExecutor(mockExecPromiseFn, 'session-123');
      await executor.executeCommand('test');

      const calledWith = mockExecPromiseFn.mock.calls.find(call =>
        call[0].includes('osascript') && call[0].includes('write text')
      );
      expect(calledWith[0]).toContain('if id of s is "session-123"');
      expect(calledWith[0]).toContain('repeat with w in windows');
    });

    test('retrieves TTY for specific session', async () => {
      const executor = new CommandExecutor(mockExecPromiseFn, 'session-456');
      await executor.executeCommand('test');

      const ttyCall = mockExecPromiseFn.mock.calls.find(call =>
        call[0].includes('get tty') || call[0].includes('tty of s')
      );
      expect(ttyCall[0]).toContain('session-456');
    });

    test('checks processing status for specific session', async () => {
      const executor = new CommandExecutor(mockExecPromiseFn, 'session-789');
      await executor.executeCommand('test');

      const processingCall = mockExecPromiseFn.mock.calls.find(call =>
        call[0].includes('is processing')
      );
      expect(processingCall[0]).toContain('session-789');
    });
  });
});
